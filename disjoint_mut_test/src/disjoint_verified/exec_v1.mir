// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn <impl at exec_v1.rs:18:1: 18:18>::wf(_1: Borrow<T>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: !;

    bb0: {
        _2 = Borrow::<T>::wf::panic_cold_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:18:1: 18:18>::wf::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

// MIR FOR CTFE
fn <impl at exec_v1.rs:18:1: 18:18>::wf::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        ConstEvalCounter;
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:18:1: 18:18>::value(_1: Borrow<T>) -> T {
    debug self => _1;
    let mut _0: T;
    let _2: !;

    bb0: {
        _2 = Borrow::<T>::value::panic_cold_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:18:1: 18:18>::value::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

// MIR FOR CTFE
fn <impl at exec_v1.rs:18:1: 18:18>::value::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        ConstEvalCounter;
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:18:1: 18:18>::index(_1: Borrow<T>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let _2: !;

    bb0: {
        _2 = Borrow::<T>::index::panic_cold_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:18:1: 18:18>::index::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

// MIR FOR CTFE
fn <impl at exec_v1.rs:18:1: 18:18>::index::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        ConstEvalCounter;
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:18:1: 18:18>::ptr(_1: &Borrow<T>) -> vstd::simple_pptr::PPtr<T> {
    debug self => _1;
    let mut _0: vstd::simple_pptr::PPtr<T>;
    let _2: !;

    bb0: {
        _2 = Borrow::<T>::ptr::panic_cold_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:18:1: 18:18>::ptr::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

// MIR FOR CTFE
fn <impl at exec_v1.rs:18:1: 18:18>::ptr::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        ConstEvalCounter;
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:18:1: 18:18>::read(_1: &Borrow<T>) -> &T {
    debug self => _1;
    let mut _0: &T;
    let mut _2: vstd::simple_pptr::PPtr<T>;
    let mut _3: vstd::prelude::Tracked<&vstd::simple_pptr::PointsTo<T>>;
    let mut _4: fn() -> &vstd::simple_pptr::PointsTo<T>;

    bb0: {
        _2 = copy ((*_1).1: vstd::simple_pptr::PPtr<T>);
        _4 = const ZeroSized: {closure@exec_v1.rs:39:25: 39:52} as fn() -> &vstd::simple_pptr::PointsTo<T> (PointerCoercion(ClosureFnPointer(Safe)));
        _3 = vstd::prelude::Tracked::<&vstd::simple_pptr::PointsTo<T>>::assume_new_fallback(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = vstd::simple_pptr::PPtr::<T>::borrow(move _2, const ZeroSized: vstd::prelude::Tracked<&vstd::simple_pptr::PointsTo<T>>) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn <impl at exec_v1.rs:18:1: 18:18>::read::{closure#0}(_1: &{closure@exec_v1.rs:39:25: 39:52}) -> &vstd::simple_pptr::PointsTo<T> {
    let mut _0: &vstd::simple_pptr::PointsTo<T>;
    let mut _2: !;

    bb0: {
        _2 = core::panicking::panic(const "internal error: entered unreachable code") -> unwind continue;
    }
}

fn <impl at exec_v1.rs:18:1: 18:18>::replace(_1: &mut Borrow<T>, _2: T) -> T {
    debug self => _1;
    debug x => _2;
    let mut _0: T;
    let mut _3: vstd::simple_pptr::PPtr<T>;
    let mut _4: vstd::prelude::Tracked<&mut vstd::simple_pptr::PointsTo<T>>;
    let mut _5: fn() -> &mut vstd::simple_pptr::PointsTo<T>;
    let mut _6: T;
    let mut _7: bool;

    bb0: {
        _7 = const false;
        _7 = const true;
        _3 = copy ((*_1).1: vstd::simple_pptr::PPtr<T>);
        _5 = const ZeroSized: {closure@exec_v1.rs:52:26: 52:57} as fn() -> &mut vstd::simple_pptr::PointsTo<T> (PointerCoercion(ClosureFnPointer(Safe)));
        _4 = vstd::prelude::Tracked::<&mut vstd::simple_pptr::PointsTo<T>>::assume_new_fallback(move _5) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _7 = const false;
        _6 = move _2;
        _0 = vstd::simple_pptr::PPtr::<T>::replace(move _3, const ZeroSized: vstd::prelude::Tracked<&mut vstd::simple_pptr::PointsTo<T>>, move _6) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        resume;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        switchInt(copy _7) -> [0: bb3, otherwise: bb4];
    }
}

fn <impl at exec_v1.rs:18:1: 18:18>::replace::{closure#0}(_1: &{closure@exec_v1.rs:52:26: 52:57}) -> &mut vstd::simple_pptr::PointsTo<T> {
    let mut _0: &mut vstd::simple_pptr::PointsTo<T>;
    let mut _2: !;

    bb0: {
        _2 = core::panicking::panic(const "internal error: entered unreachable code") -> unwind continue;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::len(_1: &Array<T>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let _2: !;

    bb0: {
        _2 = Array::<T>::len::panic_cold_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::len::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

// MIR FOR CTFE
fn <impl at exec_v1.rs:56:1: 56:17>::len::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        ConstEvalCounter;
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::length(_1: &Array<T>) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: &std::vec::Vec<vstd::simple_pptr::PPtr<T>>;

    bb0: {
        _2 = &((*_1).0: std::vec::Vec<vstd::simple_pptr::PPtr<T>>);
        _0 = std::vec::Vec::<vstd::simple_pptr::PPtr<T>>::len(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::wf(_1: Array<T>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: !;

    bb0: {
        _2 = Array::<T>::wf::panic_cold_explicit() -> bb1;
    }

    bb1 (cleanup): {
        drop(_1) -> [return: bb2, unwind terminate(cleanup)];
    }

    bb2 (cleanup): {
        resume;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::wf::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

// MIR FOR CTFE
fn <impl at exec_v1.rs:56:1: 56:17>::wf::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        ConstEvalCounter;
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::all_available(_1: Array<T>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: !;

    bb0: {
        _2 = Array::<T>::all_available::panic_cold_explicit() -> bb1;
    }

    bb1 (cleanup): {
        drop(_1) -> [return: bb2, unwind terminate(cleanup)];
    }

    bb2 (cleanup): {
        resume;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::all_available::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

// MIR FOR CTFE
fn <impl at exec_v1.rs:56:1: 56:17>::all_available::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        ConstEvalCounter;
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::ptrs(_1: Array<T>) -> vstd::seq::Seq<vstd::simple_pptr::PPtr<T>> {
    debug self => _1;
    let mut _0: vstd::seq::Seq<vstd::simple_pptr::PPtr<T>>;
    let _2: !;

    bb0: {
        _2 = Array::<T>::ptrs::panic_cold_explicit() -> bb1;
    }

    bb1 (cleanup): {
        drop(_1) -> [return: bb2, unwind terminate(cleanup)];
    }

    bb2 (cleanup): {
        resume;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::ptrs::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

// MIR FOR CTFE
fn <impl at exec_v1.rs:56:1: 56:17>::ptrs::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        ConstEvalCounter;
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::availability_unchanged(_1: Array<T>, _2: Array<T>, _3: usize) -> bool {
    debug old => _1;
    debug new => _2;
    debug i => _3;
    let mut _0: bool;
    let _4: !;

    bb0: {
        _4 = Array::<T>::availability_unchanged::panic_cold_explicit() -> bb1;
    }

    bb1 (cleanup): {
        drop(_2) -> [return: bb2, unwind terminate(cleanup)];
    }

    bb2 (cleanup): {
        drop(_1) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb3 (cleanup): {
        resume;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::availability_unchanged::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

// MIR FOR CTFE
fn <impl at exec_v1.rs:56:1: 56:17>::availability_unchanged::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        ConstEvalCounter;
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::borrows_unchanged(_1: Array<T>, _2: Array<T>) -> bool {
    debug old => _1;
    debug new => _2;
    let mut _0: bool;
    let _3: !;

    bb0: {
        _3 = Array::<T>::borrows_unchanged::panic_cold_explicit() -> bb1;
    }

    bb1 (cleanup): {
        drop(_2) -> [return: bb2, unwind terminate(cleanup)];
    }

    bb2 (cleanup): {
        drop(_1) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb3 (cleanup): {
        resume;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::borrows_unchanged::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

// MIR FOR CTFE
fn <impl at exec_v1.rs:56:1: 56:17>::borrows_unchanged::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        ConstEvalCounter;
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::available(_1: Array<T>, _2: usize) -> bool {
    debug self => _1;
    debug i => _2;
    let mut _0: bool;
    let _3: !;

    bb0: {
        _3 = Array::<T>::available::panic_cold_explicit() -> bb1;
    }

    bb1 (cleanup): {
        drop(_1) -> [return: bb2, unwind terminate(cleanup)];
    }

    bb2 (cleanup): {
        resume;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::available::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

// MIR FOR CTFE
fn <impl at exec_v1.rs:56:1: 56:17>::available::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        ConstEvalCounter;
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::corresponds(_1: Array<T>, _2: Borrow<T>) -> bool {
    debug self => _1;
    debug borrow => _2;
    let mut _0: bool;
    let _3: !;

    bb0: {
        _3 = Array::<T>::corresponds::panic_cold_explicit() -> bb1;
    }

    bb1 (cleanup): {
        drop(_1) -> [return: bb2, unwind terminate(cleanup)];
    }

    bb2 (cleanup): {
        resume;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::corresponds::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

// MIR FOR CTFE
fn <impl at exec_v1.rs:56:1: 56:17>::corresponds::panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        ConstEvalCounter;
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::new(_1: std::vec::Vec<T>) -> Array<T> {
    debug data => _1;
    let mut _0: Array<T>;
    let mut _2: std::vec::Vec<T>;
    let mut _3: bool;
    let mut _4: usize;
    let mut _5: &std::vec::Vec<T>;
    let _6: ();
    let mut _7: &mut std::vec::Vec<T>;
    let mut _8: T;
    let mut _9: std::option::Option<T>;
    let mut _10: &mut std::vec::Vec<T>;
    let mut _13: bool;
    let mut _14: usize;
    let mut _15: &std::vec::Vec<T>;
    let mut _17: std::option::Option<T>;
    let mut _18: &mut std::vec::Vec<T>;
    let mut _20: (vstd::simple_pptr::PPtr<T>, vstd::prelude::Tracked<vstd::simple_pptr::PointsTo<T>>);
    let _21: ();
    let mut _22: &mut std::vec::Vec<vstd::simple_pptr::PPtr<T>>;
    let mut _23: (usize, bool);
    let mut _24: std::vec::Vec<vstd::simple_pptr::PPtr<T>>;
    let mut _25: vstd::prelude::Tracked<vstd::map::Map<usize, vstd::simple_pptr::PointsTo<T>>>;
    let mut _26: fn() -> vstd::map::Map<usize, vstd::simple_pptr::PointsTo<T>>;
    let mut _27: bool;
    scope 1 {
        debug data_rev => _2;
        let mut _11: std::vec::Vec<vstd::simple_pptr::PPtr<T>>;
        scope 2 {
            debug ptrs => _11;
            let mut _12: usize;
            scope 3 {
                debug i => _12;
                let _16: T;
                scope 4 {
                    debug x => _16;
                    let _19: vstd::simple_pptr::PPtr<T>;
                    scope 5 {
                        debug ptr => _19;
                        debug verus_tmp_perm => const ZeroSized: vstd::prelude::Tracked<vstd::simple_pptr::PointsTo<T>>;
                    }
                }
            }
        }
    }

    bb0: {
        _27 = const false;
        _2 = std::vec::Vec::<T>::new() -> [return: bb26, unwind: bb22];
    }

    bb1: {
        _5 = &_1;
        _4 = std::vec::Vec::<T>::len(move _5) -> [return: bb2, unwind: bb21];
    }

    bb2: {
        _3 = Gt(move _4, const 0_usize);
        switchInt(move _3) -> [0: bb6, otherwise: bb3];
    }

    bb3: {
        _7 = &mut _2;
        _10 = &mut _1;
        _9 = std::vec::Vec::<T>::pop(move _10) -> [return: bb4, unwind: bb21];
    }

    bb4: {
        _8 = std::option::Option::<T>::unwrap(move _9) -> [return: bb5, unwind: bb21];
    }

    bb5: {
        _6 = std::vec::Vec::<T>::push(move _7, move _8) -> [return: bb27, unwind: bb21];
    }

    bb6: {
        _11 = std::vec::Vec::<vstd::simple_pptr::PPtr<T>>::new() -> [return: bb7, unwind: bb21];
    }

    bb7: {
        _27 = const true;
        _12 = const 0_usize;
        goto -> bb8;
    }

    bb8: {
        _15 = &_2;
        _14 = std::vec::Vec::<T>::len(move _15) -> [return: bb9, unwind: bb25];
    }

    bb9: {
        _13 = Gt(move _14, const 0_usize);
        switchInt(move _13) -> [0: bb16, otherwise: bb10];
    }

    bb10: {
        _18 = &mut _2;
        _17 = std::vec::Vec::<T>::pop(move _18) -> [return: bb11, unwind: bb25];
    }

    bb11: {
        _16 = std::option::Option::<T>::unwrap(move _17) -> [return: bb12, unwind: bb25];
    }

    bb12: {
        _20 = vstd::simple_pptr::PPtr::<T>::new(move _16) -> [return: bb13, unwind: bb25];
    }

    bb13: {
        _19 = copy (_20.0: vstd::simple_pptr::PPtr<T>);
        _22 = &mut _11;
        _21 = std::vec::Vec::<vstd::simple_pptr::PPtr<T>>::push(move _22, copy _19) -> [return: bb14, unwind: bb25];
    }

    bb14: {
        _23 = AddWithOverflow(copy _12, const 1_usize);
        assert(!move (_23.1: bool), "attempt to compute `{} + {}`, which would overflow", copy _12, const 1_usize) -> [success: bb15, unwind: bb25];
    }

    bb15: {
        _12 = move (_23.0: usize);
        goto -> bb8;
    }

    bb16: {
        _27 = const false;
        _24 = move _11;
        _26 = const ZeroSized: {closure@exec_v1.rs:141:20: 141:34} as fn() -> vstd::map::Map<usize, vstd::simple_pptr::PointsTo<T>> (PointerCoercion(ClosureFnPointer(Safe)));
        _25 = vstd::prelude::Tracked::<vstd::map::Map<usize, vstd::simple_pptr::PointsTo<T>>>::assume_new_fallback(move _26) -> [return: bb17, unwind: bb20];
    }

    bb17: {
        _0 = Array::<T> { ptrs: move _24, perms: const ZeroSized: vstd::prelude::Tracked<vstd::map::Map<usize, vstd::simple_pptr::PointsTo<T>>> };
        _27 = const false;
        drop(_2) -> [return: bb18, unwind: bb22];
    }

    bb18: {
        drop(_1) -> [return: bb19, unwind continue];
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_24) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        drop(_2) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        drop(_1) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        resume;
    }

    bb24 (cleanup): {
        drop(_11) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        switchInt(copy _27) -> [0: bb21, otherwise: bb24];
    }

    bb26: {
        goto -> bb1;
    }

    bb27: {
        goto -> bb1;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::new::{closure#0}(_1: &{closure@exec_v1.rs:141:20: 141:34}) -> vstd::map::Map<usize, vstd::simple_pptr::PointsTo<T>> {
    let mut _0: vstd::map::Map<usize, vstd::simple_pptr::PointsTo<T>>;
    let mut _2: !;

    bb0: {
        _2 = core::panicking::panic(const "internal error: entered unreachable code") -> unwind continue;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::borrow(_1: &mut Array<T>, _2: usize) -> Borrow<T> {
    debug self => _1;
    debug i => _2;
    let mut _0: Borrow<T>;
    let _3: vstd::simple_pptr::PPtr<T>;
    let mut _4: &vstd::simple_pptr::PPtr<T>;
    let mut _5: &std::vec::Vec<vstd::simple_pptr::PPtr<T>>;
    let mut _6: vstd::prelude::Tracked<vstd::simple_pptr::PointsTo<T>>;
    let mut _7: fn() -> vstd::simple_pptr::PointsTo<T>;
    scope 1 {
        debug ptr => _3;
    }

    bb0: {
        _5 = &((*_1).0: std::vec::Vec<vstd::simple_pptr::PPtr<T>>);
        _4 = <std::vec::Vec<vstd::simple_pptr::PPtr<T>> as std::ops::Index<usize>>::index(move _5, copy _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = copy (*_4);
        _7 = const ZeroSized: {closure@exec_v1.rs:163:19: 163:32} as fn() -> vstd::simple_pptr::PointsTo<T> (PointerCoercion(ClosureFnPointer(Safe)));
        _6 = vstd::prelude::Tracked::<vstd::simple_pptr::PointsTo<T>>::assume_new_fallback(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = Borrow::<T> { index: copy _2, ptr: copy _3, perm: const ZeroSized: vstd::prelude::Tracked<vstd::simple_pptr::PointsTo<T>> };
        return;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::borrow::{closure#0}(_1: &{closure@exec_v1.rs:163:19: 163:32}) -> vstd::simple_pptr::PointsTo<T> {
    let mut _0: vstd::simple_pptr::PointsTo<T>;
    let mut _2: !;

    bb0: {
        _2 = core::panicking::panic(const "internal error: entered unreachable code") -> unwind continue;
    }
}

fn <impl at exec_v1.rs:56:1: 56:17>::terminate(_1: &mut Array<T>, _2: Borrow<T>) -> () {
    debug self => _1;
    debug b => _2;
    let mut _0: ();
    scope 1 {
        debug verus_tmp_perm => const ZeroSized: vstd::prelude::Tracked<vstd::simple_pptr::PointsTo<T>>;
    }

    bb0: {
        return;
    }
}

fn tests::read(_1: &i32) -> () {
    debug x => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn tests::print(_1: &mut Array<T>) -> () {
    debug a => _1;
    let mut _0: ();
    let mut _2: std::ops::Range<usize>;
    let mut _3: std::ops::Range<usize>;
    let mut _4: usize;
    let mut _5: &Array<T>;
    let mut _6: std::ops::Range<usize>;
    let mut _7: std::option::Option<usize>;
    let mut _8: &mut std::ops::Range<usize>;
    let mut _9: isize;
    let _12: ();
    let mut _13: std::fmt::Arguments<'_>;
    let _14: &[&str; 2];
    let _15: &[core::fmt::rt::Argument<'_>; 1];
    let _16: [core::fmt::rt::Argument<'_>; 1];
    let mut _17: core::fmt::rt::Argument<'_>;
    let _18: &&T;
    let _19: &T;
    let mut _20: &Borrow<T>;
    let _21: ();
    let _22: ();
    let mut _23: std::fmt::Arguments<'_>;
    let _24: &[&str; 1];
    scope 1 {
        debug iter => _6;
        let _10: usize;
        scope 2 {
            debug i => _10;
            let _11: Borrow<T>;
            scope 3 {
                debug b => _11;
            }
        }
    }

    bb0: {
        _5 = &(*_1);
        _4 = Array::<T>::length(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = std::ops::Range::<usize> { start: const 0_usize, end: move _4 };
        _2 = <std::ops::Range<usize> as std::iter::IntoIterator>::into_iter(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = move _2;
        goto -> bb3;
    }

    bb3: {
        _8 = &mut _6;
        _7 = <std::ops::Range<usize> as std::iter::Iterator>::next(copy _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb7, 1: bb6, otherwise: bb5];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _10 = copy ((_7 as Some).0: usize);
        _11 = Array::<T>::borrow(copy _1, copy _10) -> [return: bb8, unwind continue];
    }

    bb7: {
        _24 = const tests::print::<T>::promoted[1];
        _23 = std::fmt::Arguments::<'_>::new_const::<1>(copy _24) -> [return: bb13, unwind continue];
    }

    bb8: {
        _14 = const tests::print::<T>::promoted[0];
        _20 = &_11;
        _19 = Borrow::<T>::read(move _20) -> [return: bb9, unwind continue];
    }

    bb9: {
        _18 = &_19;
        _17 = core::fmt::rt::Argument::<'_>::new_debug::<&T>(copy _18) -> [return: bb10, unwind continue];
    }

    bb10: {
        _16 = [move _17];
        _15 = &_16;
        _13 = std::fmt::Arguments::<'_>::new_v1::<2, 1>(copy _14, copy _15) -> [return: bb11, unwind continue];
    }

    bb11: {
        _12 = std::io::_print(move _13) -> [return: bb12, unwind continue];
    }

    bb12: {
        _21 = Array::<T>::terminate(copy _1, move _11) -> [return: bb3, unwind continue];
    }

    bb13: {
        _22 = std::io::_print(move _23) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }
}

const tests::print::promoted[0]: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const " "];
        _0 = &_1;
        return;
    }
}

const tests::print::promoted[1]: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

fn tests::f() -> () {
    let mut _0: ();
    let mut _1: Array<i32>;
    let mut _2: std::vec::Vec<i32>;
    let mut _3: std::boxed::Box<[i32]>;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: *mut u8;
    let mut _7: std::boxed::Box<[i32; 3]>;
    let mut _9: &mut Array<i32>;
    let mut _11: &mut Array<i32>;
    let _12: &i32;
    let mut _13: &Borrow<i32>;
    let mut _15: &Borrow<i32>;
    let _16: i32;
    let mut _17: &mut Borrow<i32>;
    let _18: i32;
    let mut _19: &mut Borrow<i32>;
    let _20: ();
    let mut _21: &mut Array<i32>;
    let mut _22: Borrow<i32>;
    let _23: ();
    let mut _24: &mut Array<i32>;
    let mut _25: Borrow<i32>;
    let _26: ();
    let mut _27: &mut Array<i32>;
    let mut _28: *const [i32; 3];
    let mut _29: *const ();
    let mut _30: usize;
    let mut _31: usize;
    let mut _32: usize;
    let mut _33: usize;
    let mut _34: bool;
    scope 1 {
        debug array => _1;
        let mut _8: Borrow<i32>;
        scope 2 {
            debug b0 => _8;
            let mut _10: Borrow<i32>;
            scope 3 {
                debug b1 => _10;
                scope 4 {
                    debug b0_i => _12;
                    let _14: &i32;
                    scope 5 {
                        debug b0_ii => _14;
                    }
                }
            }
        }
    }

    bb0: {
        _4 = SizeOf([i32; 3]);
        _5 = AlignOf([i32; 3]);
        _6 = alloc::alloc::exchange_malloc(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = ShallowInitBox(move _6, [i32; 3]);
        _28 = copy (((_7.0: std::ptr::Unique<[i32; 3]>).0: std::ptr::NonNull<[i32; 3]>).0: *const [i32; 3]);
        _29 = copy _28 as *const () (PtrToPtr);
        _30 = copy _29 as usize (Transmute);
        _31 = AlignOf([i32; 3]);
        _32 = Sub(copy _31, const 1_usize);
        _33 = BitAnd(copy _30, copy _32);
        _34 = Eq(copy _33, const 0_usize);
        assert(copy _34, "misaligned pointer dereference: address must be a multiple of {} but is {}", copy _31, copy _30) -> [success: bb16, unwind unreachable];
    }

    bb2: {
        _1 = Array::<i32>::new(move _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = &mut _1;
        _8 = Array::<i32>::borrow(move _9, const 0_usize) -> [return: bb4, unwind: bb14];
    }

    bb4: {
        _11 = &mut _1;
        _10 = Array::<i32>::borrow(move _11, const 1_usize) -> [return: bb5, unwind: bb14];
    }

    bb5: {
        _13 = &_8;
        _12 = Borrow::<i32>::read(move _13) -> [return: bb6, unwind: bb14];
    }

    bb6: {
        _15 = &_8;
        _14 = Borrow::<i32>::read(move _15) -> [return: bb7, unwind: bb14];
    }

    bb7: {
        _17 = &mut _8;
        _16 = Borrow::<i32>::replace(move _17, const 66_i32) -> [return: bb8, unwind: bb14];
    }

    bb8: {
        _19 = &mut _10;
        _18 = Borrow::<i32>::replace(move _19, const 77_i32) -> [return: bb9, unwind: bb14];
    }

    bb9: {
        _21 = &mut _1;
        _22 = move _10;
        _20 = Array::<i32>::terminate(move _21, move _22) -> [return: bb10, unwind: bb14];
    }

    bb10: {
        _24 = &mut _1;
        _25 = move _8;
        _23 = Array::<i32>::terminate(move _24, move _25) -> [return: bb11, unwind: bb14];
    }

    bb11: {
        _27 = &mut _1;
        _26 = tests::print::<i32>(copy _27) -> [return: bb12, unwind: bb14];
    }

    bb12: {
        drop(_1) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }

    bb14 (cleanup): {
        drop(_1) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16: {
        (*_28) = [const 0_i32, const 1_i32, const 2_i32];
        _3 = move _7 as std::boxed::Box<[i32]> (PointerCoercion(Unsize));
        _2 = std::slice::<impl [i32]>::into_vec::<std::alloc::Global>(move _3) -> [return: bb2, unwind continue];
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ();

    bb0: {
        _1 = tests::f() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}
